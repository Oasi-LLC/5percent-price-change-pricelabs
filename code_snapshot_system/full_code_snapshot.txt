Project Code Snapshot


======= File: code_snapshot_system/README.md =======

# Code Snapshot System

A lightweight system for automatically creating and maintaining snapshots of your codebase. It watches for file changes and automatically updates a consolidated snapshot file containing all your code.

## Features
- Automatic code snapshot creation on file changes
- Configurable file extensions to watch
- Excludes common unnecessary directories (venv, __pycache__, etc.)
- Colored terminal output for status updates

## Installation

1. Copy this directory to your project root
2. Install dependencies:
```bash
pip install -r requirements.txt
```

## Usage

### One-time Snapshot
To create a single snapshot of your codebase:
```bash
python create_code_snapshot.py
```

### Auto-update Snapshot
To start the file watcher that automatically updates the snapshot on changes:
```bash
python auto-snapshot.py
```

### Configuration
Edit the following variables in the scripts to customize behavior:

In `auto-snapshot.py`:
- `WATCHED_EXTENSIONS`: File extensions to monitor
- `SNAPSHOT_FILE`: Output snapshot file path

In `create_code_snapshot.py`:
- `EXCLUDE_DIRS`: Directories to exclude
- `include_file_extensions`: File types to include in snapshot

## Output
The system creates a `full_code_snapshot.txt` file in your project root containing all your code in a readable format. 

======= File: code_snapshot_system/auto-snapshot.py =======

import time
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from pathlib import Path
from termcolor import colored

# Use relative import
from create_code_snapshot import create_code_snapshot

# Define which file extensions we want to watch
WATCHED_EXTENSIONS = {".py", ".md", ".txt", ".yaml", ".yml", ".json", ".css", ".js", ".html"}
SNAPSHOT_FILE = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "full_code_snapshot.txt")

class CodeChangeHandler(FileSystemEventHandler):
    def on_modified(self, event):
        # Ignore directory-level events and the snapshot file itself
        if event.is_directory or Path(event.src_path).name == Path(SNAPSHOT_FILE).name:
            return
        
        # Check if the modified file has an extension we care about
        file_extension = Path(event.src_path).suffix.lower()
        if file_extension in WATCHED_EXTENSIONS:
            print(colored(f"File changed: {event.src_path}. Updating code snapshot...", "yellow"))
            try:
                # Move up one directory to project root
                os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
                create_code_snapshot(
                    directories=["."], 
                    output_file=SNAPSHOT_FILE
                )
                print(colored("✓ Snapshot updated successfully", "green"))
            except Exception as e:
                print(colored(f"✗ Error updating snapshot: {str(e)}", "red"))

if __name__ == "__main__":
    # Move up one directory to project root
    os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    watch_directory = "."  # Watch from project root
    event_handler = CodeChangeHandler()
    observer = Observer()
    observer.schedule(event_handler, watch_directory, recursive=True)

    print(colored(f"Starting watch on '{os.path.abspath(watch_directory)}'...", "cyan"))
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print(colored("\nStopping file watch...", "yellow"))
        observer.stop()
    observer.join()

======= File: code_snapshot_system/create_code_snapshot.py =======

import os
from pathlib import Path

def create_code_snapshot(
    directories=["."],
    output_file="full_code_snapshot.txt",
    include_file_extensions=(".py", ".md", ".txt", ".yaml", ".yml", ".toml", ".json", ".css", ".js", ".html")
):
    """
    Recursively collects all code files from the specified directories and concatenates them into a single file.

    Args:
        directories (list): A list of directories to scan recursively.
        output_file (str): The path to the output file containing the concatenated code.
        include_file_extensions (tuple): A tuple of file extensions to include.
        
    Returns:
        str: The path to the generated code snapshot file.
    """

    # Resolve directories relative to current working directory
    resolved_dirs = [Path(d).resolve() for d in directories]

    # Prepare output file
    output_path = Path(output_file).resolve()
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Directories to exclude
    EXCLUDE_DIRS = {
        'venv',
        '__pycache__',
        '.git',
        '.pytest_cache',
        'node_modules',
        'backups',
        'no-code-architects-toolkit'
    }

    with open(output_path, "w", encoding="utf-8") as out_f:
        # Write header
        out_f.write("Project Code Snapshot\n\n")
        
        for directory in resolved_dirs:
            if not directory.exists():
                print(f"Warning: Directory {directory} does not exist, skipping.")
                continue
            
            # Walk through the directory structure
            for root, dirs, files in os.walk(directory):
                # Remove excluded directories
                dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
                
                # Sort files for consistency
                files.sort()

                for file_name in files:
                    file_path = Path(root) / file_name
                    # Skip the snapshot file itself and hidden files
                    if file_path.name == output_path.name or file_path.name.startswith('.'):
                        continue
                    # Check file extension
                    if file_path.suffix.lower() in include_file_extensions:
                        # Write a header for each file
                        out_f.write(f"\n======= File: {file_path.relative_to(directory.parent)} =======\n\n")
                        
                        # Read and append file content
                        try:
                            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                                content = f.read()
                            out_f.write(content)
                            out_f.write("\n")
                        except Exception as e:
                            print(f"Error reading {file_path}: {e}")
                            continue
    
    print(f"Code snapshot created at: {output_path}")
    return str(output_path)

# Example usage:
if __name__ == "__main__":
    snapshot_path = create_code_snapshot()

======= File: code_snapshot_system/requirements.txt =======

watchdog
termcolor

